
=pod

=head1 COPYRIGHT

# (c) 1992-2020 Intel Corporation.                            
# Intel, the Intel logo, Intel, MegaCore, NIOS II, Quartus and TalkBack words    
# and logos are trademarks of Intel Corporation or its subsidiaries in the U.S.  
# and/or other countries. Other marks and brands may be claimed as the property  
# of others. See Trademarks on intel.com for full list of Intel trademarks or    
# the Trademarks & Brands Names Database (if Intel) or See www.Intel.com/legal (if Altera) 
# Your use of Intel Corporation's design tools, logic functions and other        
# software and tools, and its AMPP partner logic functions, and any output       
# files any of the foregoing (including device programming or simulation         
# files), and any associated documentation or information are expressly subject  
# to the terms and conditions of the Altera Program License Subscription         
# Agreement, Intel MegaCore Function License Agreement, or other applicable      
# license agreement, including, without limitation, that your use is for the     
# sole purpose of programming logic devices manufactured by Intel and sold by    
# Intel or its authorized distributors.  Please refer to the applicable          
# agreement for further details.                                                 


=cut

package acl::Simulator;
require acl::Common;
require acl::Env;
require acl::File;
require acl::AOCDriverCommon;

@ISA        = qw(Exporter);
@EXPORT     = ();
@EXPORT_OK  = qw(
    set_sim_debug
    set_sim_debug_depth
    set_sim_accurate_memory
    set_sim_kernel_clk_frequency
    set_sim_enable_warnings
    set_sim_elab_options
    set_sim_library_to_aoc
    set_sim_library_to_hls
    initialize_simulation_paths
    get_sim_compile_exe
    get_sim_run_tcl
    get_sim_package
    get_sim_options
    generate_simulation_scripts
    opencl_create_sim_system
    compile_opencl_simulator
    write_sim_repackage_script
);

use strict;


my $module = 'acl::Simulator';

=head1 NAME

acl::Simulator - Simulator utilities

=head1 VERSION

$Header: //depot/sw/hld/rel/20.3api.11/acl/sysgen/lib/acl/Simulator.pm#1 $

=head1 SYNOPSIS


=head1 DESCRIPTION

This module provides utilities for create the OpenCL and HLS simulation framework.

All methods names may optionally be imported, e.g.:

   use acl::Simulator qw( compile_opencl_simulator );

=head1 METHODS

=cut

# Simulation options set by user
my $sim_debug = 0;    # 1 means add elaboration option to output vsim.wlf when running the simulation
                      # 0 means no waveform to speed up running time and reduce diskspace usage (default)
my $sim_debug_depth = undef;  # sets the hierarchy depth to capture into vsim.wlf. Applicable when $sim_debug=1
                              # Special case is undef, it means capture all, set with only -ghdl flag with no depth #
my $sim_accurate_memory = 0;
my $sim_kernel_clk_frequency = 400;  # in MHz
my $sim_enable_warnings = 0;  # 0 means suppress missing ports and parameter warnings
my $sim_user_elab_options = "";

my $qsys_temp_dir = "aoc_msim.temp";     # directory that contains mpsim.qsys. Default value used by less-QSys option
my $qsys_temp_dir_path = undef;          # absolute directory path name to simulation folder
my $cosim_lib = undef;                   # cosim library determined by flow

# Compilation flow used. 3 levels of QSys:
#  1) Whole simulation framework is generated by QSys - existing simulation framework
#  2) Only the simulation board is generated by QSys  - SDK provide default with skip QSys for kernel system
#  3) Only the kernel_system is generated by QSys     - vendor board sim with QSys-less flow, i.e. S10
my $board_qsys = 0;         # 1: whole simulation framework; 0: simulation board only
my $kernel_system_qsys = 0; # 1: not currently supported

# Simulation working directory and script paths. Set by initialize_simulation_paths()
# QSys infrastructure generates $QSYS_SIMDIR to put all the sim scripts and the RTL and files are located in ip/$QSYS_SIMDIR
my $sim_qsys_name = undef;   # QSys project name.
my $sim_dir = undef;         # Store the variable to define $QSYS_SIMDIR
my $sim_script_dir = undef;  # location of the generated compile and run scripts. 
                             # With ModelSim: Qsys sim directory == compile directory, but VCSMX is different
my $sim_compile_script_name = undef;  # msim_compile.tcl'
my $fname_runscript = undef;
my $fname_exe_com_script = undef;

# OpenCL specific package and kernel system instance name
my @sim_package = ('ip','board_spec.xml');       # for adding files and directories to aocx
my $kernel_system_inst = "ks";

sub set_sim_debug($) {
  $sim_debug = shift;
}

sub set_sim_debug_depth($) {
  $sim_debug_depth = shift;
}

sub set_sim_accurate_memory($) {
  $sim_accurate_memory = shift;
}

sub set_sim_kernel_clk_frequency($) {
  $sim_kernel_clk_frequency = shift;
}

sub set_sim_enable_warnings($) {
  $sim_enable_warnings = shift;
}

sub set_sim_elab_options {
  $sim_user_elab_options = shift;
}

# Set the pre-generated input directory use by OpenCL -sim-input-dir flag
sub set_sim_dir_path($) {
  my $sim_path = shift;
  if (!defined($sim_path)) {
    # user did not provide a path, use default aoc_msim.temp
  	$sim_path = $qsys_temp_dir;
  }
  $qsys_temp_dir_path = acl::File::abs_path($sim_path);
  acl::Common::mydie("User specified simulation directory ${sim_path} does not exist: $!") if (! (-e $qsys_temp_dir_path));
  $qsys_temp_dir = acl::File::mybasename($qsys_temp_dir_path);
}

sub set_sim_library_to_aoc {
  $cosim_lib = "aoc_cosim_msim";
}

sub set_sim_library_to_hls {
  $cosim_lib = "hls_cosim_msim";
}

# initialize_simulation_paths needs to be called before generate_simulation_scripts()
# The functions sets the qsys project name, sim_dir that's use for QSYS_SIMDIR, 
# directory name sim_script_dir for output scripts dir, and compile and run scripts
# the script names and run scripts changes based on platform and simulator vendor
sub initialize_simulation_paths {
  my ($qsys_name, $standard) = @_;
  $sim_qsys_name = $qsys_name;
  
  if ($standard) {
    $sim_dir = $sim_qsys_name."/simulation";  # Path structure match QSys
  } else {
    $sim_dir = $sim_qsys_name."/sim";  # Path structure match QSys
  }
  # TODO: add vendor initialize code, i.e. VCS support
  $sim_script_dir = $sim_dir;
  $sim_compile_script_name = "msim_compile.tcl";    # Modelsim filename
  $fname_exe_com_script = acl::Env::is_linux() ? 'compile.sh' : 'compile.cmd';
  $fname_exe_com_script = $sim_script_dir.'/'.$fname_exe_com_script;  # put the script in sim for Modelsim
  $fname_runscript = $sim_script_dir.'/msim_run.tcl';
  # accurate memory model will require ddr, mpsim and others folders to be packaged up
  if ($sim_accurate_memory) {
    # currently it must be used with -sim-input-dir and hardcode in directories
    # some basic error checking before continuing
    if (!(-d $qsys_temp_dir_path)) {
      acl::Common::mydie("Accurate memory simulation folder $qsys_temp_dir_path does not exist!\n");
    }
    foreach my $file (acl::File::simple_glob( "$qsys_temp_dir_path/*" )) {
      # do not copy *kernel_system* from input dir because it's from empty kernel system
      next if ($file =~ /kernel_system/);
      push(@sim_package, acl::File::mybasename($file));
    }
  }
}

sub get_sim_compile_exe {
  if ( acl::Env::is_linux() ) {
    return "./$fname_exe_com_script";
  }
  elsif ( acl::Env::is_windows() ) {
    return "call $fname_exe_com_script";
  }
  acl::Common::mydie("Simulator is compiling for an unsupport OS!\n");
}

sub get_sim_run_tcl {
  return $fname_runscript;
}

sub get_sim_package {
  return @sim_package;
}

sub get_sim_options {
  return "sim_options.txt";
}

# TODO: case:555804: Commize with i++ when adding VCSMX cosim support
sub query_raw_vsim_version_string() {
    my $vsim_version_string = `vsim -version`;
    my $error_code = $?;

    if ($error_code != 0) {
      acl::Common::mydie("Error accessing ModelSim.  Please ensure you have a valid ModelSim installation on your path.\n" .
                  "       Check your ModelSim installation with \"vsim -version\" \n"); 
    }

    return $vsim_version_string;
}

sub query_vsim_version_string() {
    my $vsim_simple_str = query_raw_vsim_version_string();
    $vsim_simple_str =~ s/^\s+|\s+$//g;
    return $vsim_simple_str;
}

# TODO: case:555804: Commize with i++ when adding VCSMX cosim support
sub query_vsim_arch() {
    my $vsim_version_str = query_raw_vsim_version_string();
    my $cosim_64bit = ($vsim_version_str =~ /64 vsim/);
    return $cosim_64bit;
}

# For Linux, create a simulation run script with an updated library path that's relative
# to where the host or a.out invoke it
# For Windows, same script is used, but need to remove work_lib as Windows does not support alias to the same work folder
sub _create_run_msim_setup_file($) {
  my $filepath = shift;
  my $file = $filepath.'/mentor/msim_setup.tcl';
  my $outfile = $filepath.'/mentor/msim_setup_run.tcl';
  open(FILE, "<$file") or acl::Common::mydie("Can't open $file for read");
  my @lines;
  while(my $line = <FILE>) {
    if ( acl::Env::is_windows() ) {
      # case:595543 remove work_lib from logical_lib for Windows VMAP does not support 2 variables map to same work folder
      # also work_lib is never being used
      $line =~ s|\"work_lib\"||g;
    }
    else {
      # fix library paths
      $line =~ s|\./libraries/|$sim_dir/libraries/|g;
      # fix vsim version call because it does not work in batch mode
      $line =~ s|\[\s*vsim\s*-version\s*\]|\$VSIM_VERSION_STR|g;
    }
    push(@lines,$line);
  }
  close(FILE);
  if ( acl::Env::is_windows() ) {
    # case:595543 rewrite the original one without vlib this time
    open(OFH,">$file") or acl::Common::mydie("Can't open $file for write");
    foreach my $line (@lines) {
      print OFH $line;
    }
    close(OFH);
  }
  else {
    # output a run script with path relative to where the script is being invoke
    open(OFH,">$outfile") or acl::Common::mydie("Can't open $outfile for write");
    foreach my $line (@lines) {
      print OFH $line;
    }
    close(OFH);
  }
  return 0;
}

=head2 generate_simulation_scripts()

This module creates 3 files shown below. The function is expected to be called in the same folder as <sim>.qsys
 msim_compile.tcl     : The string run by the compilation phase, in the sim script dir
 msim_run.tcl         : The string run by the simulation phase, in the sim script dir
 compile.sh           : The scripts the allows user to recompile their design
Prerequisites:
 $sim_dir             : Directory which the compiled libraries would be created
 $sim_script_dir      : Directory which the simulations scripts reside
 $cosim_lib           : Suffix of cosim folder: [aoc_cosim_msim|hls_cosim_msim]
 $sim_debug           : if defined, Add "log -r *" to msim_run.tcl
 $sim_enable_warnings : if set to 1, it will not suppress compile and elaboration warnings

=cut

sub generate_simulation_scripts($@) {
    # list of kernel/component names for logging
    my @dut_list = @_;
    # vsim version
    my $vsim_version_string = query_vsim_version_string();

    # Library names
    # OpenCL specific setups
    # OpenCL cosim libraries
    my $cosimlib = query_vsim_arch() ? $cosim_lib : $cosim_lib.'32';
    # Script filenames
    my $fname_compilescript = $sim_script_dir.'/'.$sim_compile_script_name;
	# get the whole path for HLS since simulator can be launch outside of the i++.pl without the entry wrapper
    my $sdk_root_path = ($cosim_lib =~ /hls/) ? acl::Env::sdk_root() : "\$::env(".acl::Env::sdk_root_name().")";
    my $fname_svlib = acl::Env::sdk_root() . (acl::Env::is_linux() ? "/host/linux64/lib/lib${cosimlib}" : "/windows64/bin/${cosimlib}");

    # Create the msim_setup_run.tcl script for host to invoke
    _create_run_msim_setup_file(acl::File::abs_path($sim_dir));

    # Generate the modelsim compilation script. Compile is done in $sim_dir
    my $COMPILE_SCRIPT_FILE;
    open(COMPILE_SCRIPT_FILE, ">", $fname_compilescript) or acl::Common::mydie("Couldn't open $fname_compilescript for write!\n");
    print COMPILE_SCRIPT_FILE "onerror {abort all; exit -code 1;}\n";
    print COMPILE_SCRIPT_FILE "set VSIM_VERSION_STR \"$vsim_version_string\"\n";
    print COMPILE_SCRIPT_FILE "set QSYS_SIMDIR .\n";
    print COMPILE_SCRIPT_FILE "source mentor/msim_setup.tcl\n";
    print COMPILE_SCRIPT_FILE "set USER_DEFINED_VERILOG_COMPILE_OPTIONS \"+incdir+.";
    print COMPILE_SCRIPT_FILE " -suppress 2388" if (!$sim_enable_warnings);  # case:569080: duplicate definition
    print COMPILE_SCRIPT_FILE "\"\n";
    print COMPILE_SCRIPT_FILE "dev_com\n";  # case:532280: remove after incremental simulation compile works
    print COMPILE_SCRIPT_FILE "com\n";
    # OpenCL does not elaborate now, as it may hard code absolute pathnames, and this won't
    # work well on the farm, as they will be missing when we unpack the results.
    # HLS can elaborate for but will run into issue if folder is moved.
    if ($sim_enable_warnings) {
      print COMPILE_SCRIPT_FILE "if {\$tcl_platform(platform) == \"windows\"} {\n";
      print COMPILE_SCRIPT_FILE "  set fname_svlib \"${sdk_root_path}/windows64/bin/${cosimlib}\"\n";
      print COMPILE_SCRIPT_FILE "  set fname_svlib [string map { \"\\\\\" \"/\"} \$fname_svlib]\n";
      print COMPILE_SCRIPT_FILE "} else {\n";
      print COMPILE_SCRIPT_FILE "  set fname_svlib \"${sdk_root_path}/host/linux64/lib/lib${cosimlib}\"\n";
      print COMPILE_SCRIPT_FILE "}\n";
      print COMPILE_SCRIPT_FILE "set USER_DEFINED_ELAB_OPTIONS \"";
      print COMPILE_SCRIPT_FILE "-dpioutoftheblue 1 -sv_lib \$fname_svlib";
      if (acl::Env::is_windows()) {
          print COMPILE_SCRIPT_FILE " -nodpiexports";
      }
      print COMPILE_SCRIPT_FILE ($sim_debug ? " -voptargs=+acc\"\n"
                                            : "\"\n");
      print COMPILE_SCRIPT_FILE "elab\n";
    }
    print COMPILE_SCRIPT_FILE "exit -code 0\n";
    close(COMPILE_SCRIPT_FILE);

    # Generate the run script. Elaboration is done at the parent level, i.e. $work_dir
    my $RUN_SCRIPT_FILE;
    open(RUN_SCRIPT_FILE, ">", $fname_runscript) or acl::Common::mydie("Couldn't open $fname_runscript for write!\n");
    print RUN_SCRIPT_FILE "onerror {abort all; puts stderr \"The simulation process encountered an error and has aborted.\"; exit -code 1;}\n";
    print RUN_SCRIPT_FILE "set VSIM_VERSION_STR \"$vsim_version_string\"\n";
    print RUN_SCRIPT_FILE "if {\$tcl_platform(platform) == \"windows\"} {\n";
    print RUN_SCRIPT_FILE "  cd ${sim_dir}\n";
    print RUN_SCRIPT_FILE "  set QSYS_SIMDIR .\n";
    print RUN_SCRIPT_FILE "  set fname_svlib \"${sdk_root_path}/windows64/bin/${cosimlib}\"\n";
    print RUN_SCRIPT_FILE "  set fname_svlib [string map { \"\\\\\" \"/\"} \$fname_svlib]\n";
    print RUN_SCRIPT_FILE "  source \$QSYS_SIMDIR/mentor/msim_setup.tcl\n";
    print RUN_SCRIPT_FILE "} else {\n";
    print RUN_SCRIPT_FILE "  set QSYS_SIMDIR $sim_dir\n";
    print RUN_SCRIPT_FILE "  set fname_svlib \"${sdk_root_path}/host/linux64/lib/lib${cosimlib}\"\n";
    print RUN_SCRIPT_FILE "  source \$QSYS_SIMDIR/mentor/msim_setup_run.tcl\n";
    print RUN_SCRIPT_FILE "}\n";
    print RUN_SCRIPT_FILE "# Suppress warnings from the std arithmetic libraries\n";
    print RUN_SCRIPT_FILE "set StdArithNoWarnings 1\n";
    # TODO: case:535241 OpenCL simulator vector_add example design Unknown formal identifier
    # case:1409734405 multiply driven signals generated by system integrator
    #       remove error suppression when all RTL generated is clean
    print RUN_SCRIPT_FILE "set USER_DEFINED_ELAB_OPTIONS \"+nowarnTFMPC ";
    print RUN_SCRIPT_FILE "+nowarnBSOB -suppress 1130 -suppress 2732 -suppress 3584 -suppress 3839 -suppress 12027 " if ( ! $sim_enable_warnings );
    if ($sim_user_elab_options) {
      print RUN_SCRIPT_FILE $sim_user_elab_options." ";
    }
    print RUN_SCRIPT_FILE "-dpioutoftheblue 1 -sv_lib \$fname_svlib";
    if (acl::Env::is_windows()) {
        print RUN_SCRIPT_FILE " -nodpiexports";
        # HLS need to put the vsim.wlf file 2 directories up since the compile was done in sim_dir
        print RUN_SCRIPT_FILE " -wlf ../../vsim.wlf" if ( $sim_debug && $cosim_lib =~ /hls/ );
    }
    print RUN_SCRIPT_FILE ($sim_debug ? " -voptargs=+acc\"\n"
                                      : "\"\n");
    print RUN_SCRIPT_FILE "elab\n";
    print RUN_SCRIPT_FILE "onfinish {stop}\n";
    print RUN_SCRIPT_FILE "quietly set StdArithNoWarnings 1\n";
    if ($sim_debug) {
      # (no ghdl) : highest simulation optimization
      # ghdl      : means log all
      # ghdl[=N]  : means log up to a certain level
      print RUN_SCRIPT_FILE "set WLFFilename \$env(WLF_NAME)\n" if ( $cosim_lib =~ /aoc/ );
      if (defined($sim_debug_depth)) {
        if($cosim_lib =~ /hls/ ){
          my $capture_depth = $sim_debug_depth-1;
          foreach my $dut (@dut_list) {
              print RUN_SCRIPT_FILE "log -r ${dut}_inst/* -depth $capture_depth \n";
          }
        } else {
          # currently log all signals in kernel system instance
          # TODO: case:429038: Provide hardware simulation framework for library verification
          #        ghdl=1   : EFI  
          #        ghdl=2   : lsu's, iowr, iord
          if ($sim_debug_depth == 1) {
            print RUN_SCRIPT_FILE "log -r ${sim_qsys_name}/${kernel_system_inst}/*\n";
          }
          else {
            print RUN_SCRIPT_FILE "log -r * -depth $sim_debug_depth\n";
          }
        }
      }
      else {
        print RUN_SCRIPT_FILE "log -r *\n";
      }
    }
    print RUN_SCRIPT_FILE "run -all\n";
    print RUN_SCRIPT_FILE "set failed [expr [coverage attribute -name TESTSTATUS -concise] > 1]\n";
    print RUN_SCRIPT_FILE "exit -code \${failed}\n";
    close(RUN_SCRIPT_FILE);

    # Generate a script that we'll call to compile the design
    my $EXE_COM_FILE;
    open(EXE_COM_FILE, '>', "$fname_exe_com_script") or acl::Common::mydie("Could not open file '$fname_exe_com_script' $!");
    if (acl::Env::is_linux()) {
      print EXE_COM_FILE "#!/bin/sh\n";
      print EXE_COM_FILE "\n";
      print EXE_COM_FILE "# Identify the directory to run from\n";
      print EXE_COM_FILE "rundir=\$PWD\n";
      print EXE_COM_FILE "scripthome=\$(dirname \$0)\n";
      print EXE_COM_FILE "cd \${scripthome}\n";
      print EXE_COM_FILE "# Compile and elaborate the testbench\n";
      print EXE_COM_FILE "vsim -batch -do \"$sim_compile_script_name\"\n";
      print EXE_COM_FILE "retval=\$?\n";
      print EXE_COM_FILE "cd \${rundir}\n";
      print EXE_COM_FILE "exit \${retval}\n";
    } elsif (acl::Env::is_windows()) {
      print EXE_COM_FILE "set rundir=\%cd\%\n";
      print EXE_COM_FILE "set scripthome=\%\~dp0\n";
      print EXE_COM_FILE "cd %scripthome%\n";
      print EXE_COM_FILE "vsim -batch -do \"$sim_compile_script_name\"\n";
      print EXE_COM_FILE "set exitCode=%ERRORLEVEL%\n";
      print EXE_COM_FILE "cd %rundir%\n";
      print EXE_COM_FILE "exit /b %exitCode%\n";
    } else {
      acl::Common::mydie("Unsupported OS detected\n");
    }
    close(EXE_COM_FILE);
    if(acl::Env::is_linux()) {
      system("chmod +x $fname_exe_com_script"); 
    }
    return 0;
}

# Write out a the memory copy function file at the same location as compile to specified how host memory transfer should be done, default is bypass memory controller.
# User can update this file after a compile is complete to overwrite the transfer option to go through  memory controller
# As a workaround, it generate a dummy MACRO for EMIF instance path instead of the real one
# example of a real s10gx
# `define EMIF_BANK0_MEM tb.board_inst.acl_ddr4_s10.acl_ddr4_s10_emif_s10_0.acl_ddr4_s10_emif_s10_0.arch.arch_inst.io_tiles_wrap_inst.abphy_tiles.io_tiles_abphy_inst.mem_array_abphy_inst.mem
sub _generate_memory_copy_function($) {
  my $out_dir = shift;
  my $mem_transfer_options_filename = "aoc_sim_mcf_options.svh";
  # The OpenCL memory copy function options is manually written in 18.1 and before because EMIF IP does not have this feature available
  # User can overwrite this when they create their own function and transfer options
  return if (-e "$out_dir/$mem_transfer_options_filename");
  # Data transfer through memory controller is only meaningful to use with accurate memory
  my $sim_mem_ctrl = ($sim_accurate_memory == 1) ? 1 : 0;
  open(FH, ">$out_dir/$mem_transfer_options_filename") or acl::Common::mydie("Cannot open $sim_dir/$mem_transfer_options_filename for write\n");
  # Default is load and read data bypassing EMIF memory controller
  # When set to 1, it means host-device transfer is through use memory bank divider to EMIF. This is the default support for 19.1
  # The reason to have an option was designed to help isolate host-device transfer issue on Silicon. See Case:533638: "example_designs/multithread_vector_operation HW run failure on S10 due 
  # to result mismatch cause by apparent PCIe DMA bug" for detail description. The way the failure was isolate was use the simulator to prove bank divider and EMIF was working properly.
  # Therefore the only issue remained the PCIe DMA IP.
  # When set to 0, it means host-device transfer is through bypassing the memory bank divider. Once EMIF adds the feature, then this should be updated to always set to 0.
  # Case:525522: "Figure out EMIF unsupported temporary solution to backdoor load memory" is the request to add the support assigned to EMIF IP team.
  print FH "  localparam MODEL_HOST_MEMORY_READ      = ${sim_mem_ctrl};\n";
  print FH "  localparam MODEL_HOST_MEMORY_WRITE     = ${sim_mem_ctrl};\n";
  # In 18.1 and before, EMIF does not support HMC bypass mode, and so we used a macro and function to get translate AVL address to memory storage access
  print FH "`define EMIF_BANK0_MEM dummy_mem\n";
  print FH "  function bit [ABPHY_ADDR_W-1:0] get_emif_abphy_addr(input bit [63:0] addr);\n";
  print FH "    get_emif_abphy_addr = {{ABPHY_ADDR_W}{1'b0}};\n";
  print FH "  endfunction\n";
  close(FH);
}

# generate the include file matching in aoc_fake_pll.sv to overwrite predefined frequency
sub generate_set_sim_freq_file {
  # convert frequency to 2X clock period
  # 2x clock half period = 1/sim_kernel_clk_frequency(MHz) X 1E6 ps/us / 4
  my $clock2x_half_period = int(250000/$sim_kernel_clk_frequency);
  my $fake_pll_inc_filename = "$sim_dir/set_sim_freq.svh";

  # variable name "clock2x_half_period_ps" must be consistent with opencl_sim/aoc_fake_pll IP
  # make sure the file name is same as aoc_fake_pll.sv

  open(FH, ">$fake_pll_inc_filename") or acl::Common::mydie("Cannot open $fake_pll_inc_filename\n");
  print FH "localparam real clock2x_half_period_ps = $clock2x_half_period;\n";
  close(FH);
  return;
}

# Write a verilog and vhdl filelist
# vhdl is also supported for AOC back in 18.0 when DSPBA generates VHDL
sub _generate_kernel_system_filelist() {
  my @sv_list = ();
  my @vhdl_list = ();
  my @acl_lib_list = ();

  if ($kernel_system_qsys) {
    # kernel_system.tcl was invoked, qsys-generate files in ip/kernel_system and kernel_system
    # Parse the kernel_system/*.qip + ip/kernel_system/*.qip to get the kernel_system files
    append_rtl_filelist_recur("ip/kernel_system", \@sv_list, \@vhdl_list, \@acl_lib_list);
    append_rtl_filelist_recur("kernel_system", \@sv_list, \@vhdl_list, \@acl_lib_list);
  }
  else {
    # Only OpenCL has QSys-less flow and places files in kernel_hdl, parse the kernel_system.qip
    push @sim_package, 'kernel_hdl';
    # parse the kernel_system.qip
    _append_rtl_filelist_from_qip("kernel_system.qip", '.', \@sv_list, \@vhdl_list, \@acl_lib_list);
  }
  my $qsys_sim_tcl_script = "modelsim_files.tcl";
  # Not sure why when using Script to create it, it prepends qsys_name, but it doesn't do that when I use GUI
  my $sim_files_tcl_fname = "ip/${sim_qsys_name}/${sim_qsys_name}_${kernel_system_inst}/sim/common/".$qsys_sim_tcl_script;
  if (! -e $sim_files_tcl_fname) {
    $sim_files_tcl_fname = "ip/${sim_qsys_name}/${kernel_system_inst}/sim/common/".$qsys_sim_tcl_script;
    if (! -e $sim_files_tcl_fname) {
      acl::Common::mydie("Cannot find $sim_files_tcl_fname.\n");
    }
  }
  # remove previous design files
  my @sim_script_text = ();
  my $in_design_lib_proc = 0;
  my $in_design_files_proc = 0;
  open(FH, "$sim_files_tcl_fname") or acl::Common::mydie("Can't open $sim_files_tcl_fname for read.\n");
  while (<FH>) {
    my $text =$_;
    if ($in_design_files_proc || $in_design_lib_proc) {
      if ($text =~ /^\s+(lappend.*kernel_system\.v|dict set)/) {
        next;  # do not append previous empty shell kernel_system.v
      }
      elsif ($text =~ /return/) {
        # reset variable
        $in_design_lib_proc = 0;
        $in_design_files_proc = 0;
      }
    }
    elsif ($text =~ /get_design_libraries/) {
      $in_design_lib_proc = 1;
    }
    elsif ($text =~ /get_design_files/) {
      $in_design_files_proc = 1;
    }
    push(@sim_script_text, $_);
  }
  close(FH);
  $in_design_lib_proc = 0;
  $in_design_files_proc = 0;
  # add acl_ip library and kernel_system files
  my $sdk_root_name = acl::Env::sdk_root_name();
  my $acl_ip_lib = "acl_ip";
  my $kernel_system_lib = $sim_qsys_name."_".$kernel_system_inst;  # name match with what QSys created
  my $qsys_compile_prefix = "    lappend design_files ";
  open(FH, ">$sim_files_tcl_fname") or acl::Common::mydie("Can't open $sim_files_tcl_fname for write.\n");
  for my $text (@sim_script_text) {
    if ($in_design_lib_proc) {
      print FH $text;  # prints initialization
      print FH "    dict set libraries $acl_ip_lib 1\n";
      print FH "    dict set libraries $kernel_system_lib 1\n";
      $in_design_lib_proc = 0;
      next;
    }
    elsif ($in_design_files_proc) {
      print FH $text;  # prints initialization, i.e. set design files [list]
      foreach my $acl_ip (@acl_lib_list) {
        if ($acl_ip =~ /\.vhd$/) {
          print FH "$qsys_compile_prefix\"vcom $acl_ip    -work $acl_ip_lib\"\n";
        }
        else {
          print FH "$qsys_compile_prefix\"vlog -sv \$USER_DEFINED_VERILOG_COMPILE_OPTIONS \$USER_DEFINED_COMPILE_OPTIONS +incdir+\$::env(${sdk_root_name})/ip $acl_ip    -work acl_ip\"\n";
        }
      }
      foreach my $sv_filepath (@sv_list) {
        print FH "$qsys_compile_prefix\"vlog -sv \$USER_DEFINED_VERILOG_COMPILE_OPTIONS \\\"[normalize_path \"\$QSYS_SIMDIR/../../../../$sv_filepath\"]\\\"  -work $kernel_system_lib\"\n";
      }
      foreach my $vhdl_filepath (@vhdl_list) {
        print FH "$qsys_compile_prefix\"vcom \$USER_DEFINED_VHDL_COMPILE_OPTIONS \\\"[normalize_path \"\$QSYS_SIMDIR/../../../../$vhdl_filepath\"]\\\"  -work $kernel_system_lib\"\n";
      }
      $in_design_files_proc = 0;
      next;
    }
    elsif ($text =~ /get_design_libraries/) {
      $in_design_lib_proc = 1;
    }
    elsif ($text =~ /get_design_files/) {
      $in_design_files_proc = 1;
    }
    print FH $text;
  }
  close(FH);
  return;
}

# recursively and find all the qip files
sub append_rtl_filelist_recur($$$$) {
  my ($path, $sv_list, $vhdl_list, $acl_lib_list) = @_;

  # resursively find all the qip files in the folder
  opendir(DIR, $path) or acl::Common::mydie("Cannot open $path\n");
  my @files = readdir(DIR);
  closedir(DIR);
  foreach my $file (@files) {
    next if ($file =~ /^\.\.?$/);
    my $filepath = $path."/".$file;
    
    if ($file =~ /\.qip$/) {
      my $qip_file = $path."/".$file;
      _append_rtl_filelist_from_qip($qip_file, $path, $sv_list, $vhdl_list, $acl_lib_list);
    }
    elsif (-d $filepath) {
      append_rtl_filelist_recur($filepath, $sv_list, $vhdl_list, $acl_lib_list);
    }
  }
}

sub _append_rtl_filelist_from_qsf($$$$) {
  my ($qsf_file, $sv_list, $vhdl_list, $acl_lib_list) = @_;
  my $verbose = acl::Common::get_verbose();

  open(FILE, "<$qsf_file") or acl::Common::mydie("Can't open $qsf_file for read\n");
  while(<FILE>) {
    my $line = $_;
    if ($line =~ /(VERILOG_FILE|MISC_FILE)\s+(\S+)/) {
      my $language = $1;
      my $filepath = $2;
      if ($language eq "MISC_FILE") {
        # ignore Header files, .ip files and etc
        if ($filepath =~ /hex/) {
          # copy hex files over to $
          my $hex_file = acl::File::mybasename($filepath);
          acl::File::copy($filepath, $hex_file);
          push @sim_package, $hex_file;
        }
        next;
      }
      elsif ($filepath =~ /\$::env\S+\).*/) {
        # Library file. Modelsim is already tcl based, so path is identical
        push @{$acl_lib_list}, $filepath;
        next;
      }
    }
    elsif ($line =~ /QIP_FILE\s+(\S+)/) {
      my $qip_file = $1;
      _append_rtl_filelist_from_qip($qip_file, ".", $sv_list, $vhdl_list, $acl_lib_list);
    }
  }
  close(FILE);
}

sub _append_rtl_filelist_from_qip($$$$$) {
  my ($qip_file, $path, $sv_list, $vhdl_list, $acl_lib_list) = @_;
  my $verbose = acl::Common::get_verbose();

  open(FILE, "<$qip_file") or acl::Common::mydie("Can't open $qip_file for read\n");
  while(<FILE>) {
    my $line = $_;
    if ($line =~ /(VERILOG_FILE|VHDL_FILE|MISC_FILE).*qip_path.*\"(.*)\"/) {
      my $language = $1;
      my $filepath = $2;
      if ($language eq "MISC_FILE") {
        # ignore Header files, .ip files and etc
        if ($filepath =~ /hex/) {
          # copy hex files over to $
          my $hex_file = acl::File::mybasename($filepath);
          acl::File::copy($path."/".$filepath, $hex_file);
          push @sim_package, $hex_file;
        }
        next;
      }
      elsif ($filepath =~ /\$::env\S+\).*/) {
        # Library file. Modelsim is already tcl based, so path is identical
        push @{$acl_lib_list}, $filepath;
        next;
      }
      # a Verilog/Systemverilog or VHDL file set pointer to the right list to populate
      my $list_ptr;
      $list_ptr = ($language eq "VERILOG_FILE") ? $sv_list : $vhdl_list;
      # add the absolute path
      push @{$list_ptr}, $path."/".$filepath;
      # add files that are in workdir
      push @sim_package, $filepath if ($filepath !~ /\// && $path eq ".");
    }
  }
  close(FILE);
}

=head2 compile_opencl_simulator($prog,$fulllog, $work_dir)

Calls com function in msim_setup after simulation scripts is generated. Returns 0 when successed.
Prerequisite to calling this function is setup the simulation directory variables, i.e. sim_dir, sim_script_dir, kernel_system_inst and etc.

=cut

sub compile_opencl_simulator($$$) {
  my ($prog,$fulllog, $work_dir) = @_;
  my $verbose = acl::Common::get_verbose();
  my $quiet_mode = acl::Common::get_quiet_mode();

  # include the correct directory for package
  push @sim_package, $sim_qsys_name;
  push @sim_package, "kernel_system" if (! $board_qsys);

  # copy the relevant files over
  _opencl_sim_copy_files($work_dir);

  # set the cosim library for OpenCL
  set_sim_library_to_aoc();
  # That could be from System Integrator in old flow or from calling generate_msim_system_tcl()
  _generate_kernel_system_filelist() if ( $board_qsys );
  # Generate the fake_pll frequency as accurate memory does not run with 1 GHz
  generate_set_sim_freq_file() if ( $sim_accurate_memory );
  # Queries for Modelsim licence and creates compile and run the script
  generate_simulation_scripts(());
  print "Compiling simulation...\n" if $verbose && !$quiet_mode;
  my $cmd = get_sim_compile_exe();
  my $return_status = acl::Common::mysystem_full( 
   {'time' => 1, 'time-label' => 'compiling-simulation, ', 'stdout' => 'msim-compile.tmp', 'stderr' => '&STDOUT'},
     $cmd);
  acl::Common::move_to_log("!========== msim-compile ==========","msim-compile.tmp",$fulllog);
  $return_status == 0 or acl::Common::mydie("Simulation compile FAILED.\nRefer to ".acl::File::mybasename($work_dir)."/$fulllog for details.\n");
  print "$prog: Simulation generation done!\n" unless $quiet_mode;
  # sim dir need to be placed in aocx for aoc_msim_device to find the right location
  my $sim_path_filename = get_sim_options();
  open SIMDIR_FH, ">$sim_path_filename" or acl::Common::mydie("Couldn't open $sim_path_filename for write.\n");
  print SIMDIR_FH $sim_script_dir."\n";
  print SIMDIR_FH $sim_accurate_memory."\n";
  close SIMDIR_FH;

  return 0;
}

sub _opencl_sim_copy_files {
  my $work_dir = shift;
  # Do nothing if QSys generates everything - backward compatible
  return if !$board_qsys;
  # Only copy over hex file if vendor provides accurate memory model or less-QSys flow
  foreach my $d (@sim_package) {
    acl::File::copy_tree($qsys_temp_dir_path."/".$d, $work_dir);
  }
  # Copy hex files (for ROM's) by system integrator into simulation directory
  acl::File::copy("*.hex", $sim_script_dir);
}

=head2 opencl_create_sim_system($bsp_variant, $board_variant,$work_dir)

Create the OpenCL simulation system by calling QSys and precompile common library.
This is to create the simulation harness with an empty kernel for QSys-less flow

=cut

sub opencl_create_sim_system($$$$$$$) {
  my ($bsp_variant, $board_variant, $less_qsys, $work_dir_no_base, $bcxml_file,$fulllog, $work_dir) = @_;
  my $verbose = acl::Common::get_verbose();
  # set global variables
  $board_qsys = $less_qsys;  # skip_qsys == less_qsys == board_qsys
  my $fulllog_abs = $work_dir."/".$fulllog;

  my $acl_board_hw_path = acl::AOCDriverCommon::get_board_hw_path_from_bsp($bsp_variant,$board_variant);
  my $board_spec_xml = acl::AOCDriverCommon::find_board_spec($acl_board_hw_path);
  my $devicemodel = uc acl::Env::aocl_boardspec( "$board_spec_xml", "devicemodel");
  # Remove trailing '_.*' from devicemodel: a10_sdk -> a10
  ($devicemodel) = $devicemodel =~ /(.*)_.*/;
  my $devicefamily = acl::AOCDriverCommon::device_get_family_no_normalization($devicemodel);
  my $has_snoop =  acl::Env::aocl_boardspec( "$board_spec_xml", "has_snoop");

  my $opencl_qsys_name = "mpsim";  # qsys name match with aoc_sim_generate_qsys.tcl

  my %quartus_version = acl::AOCDriverCommon::check_quartus_env();

  if ($board_qsys == 0) {
    # flow for 18.0 and 18.1, kept for IO channel
    set_sim_dir_path(".");  # set qsys directory path same as ".", qsys directory name as work directory
    initialize_simulation_paths($opencl_qsys_name, !$quartus_version{pro});
    _opencl_sim_generate_system($devicefamily, $acl_board_hw_path, $has_snoop, $bcxml_file, $fulllog_abs);
    return;
  }
  # check for hidden flag and options for -sim-input-dir
  # In 18.1.1, this feature only supports pre-generated simulator with the QSys name mpsim via aoc_sim_generate_qsys.tcl
  if (defined($qsys_temp_dir_path)) {
    initialize_simulation_paths($opencl_qsys_name, !$quartus_version{pro});
    print "Found previous compiled testbench in $qsys_temp_dir_path. Skipping testbench generation.\n" if $verbose;
    return;
  }
  # initialize simulation qsys directory with default directory name when user did not supply one
  $qsys_temp_dir_path = $work_dir_no_base.$qsys_temp_dir;
  if (!$sim_accurate_memory) {
    initialize_simulation_paths($opencl_qsys_name, !$quartus_version{pro});
    acl::File::remove_tree($qsys_temp_dir_path) if (-e $qsys_temp_dir_path);
    acl::File::make_path($qsys_temp_dir_path) or acl::Common::mydie("Cannot create temporary simulation directory $qsys_temp_dir: $!");
    acl::Common::mydie("Cannot find $bcxml_file: $!") if (!(-e $bcxml_file));
    chdir $qsys_temp_dir_path or acl::Common::mydie("Cannot change dir into $qsys_temp_dir_path: $!");
    _opencl_sim_generate_system($devicefamily, $acl_board_hw_path, $has_snoop, $bcxml_file, $fulllog_abs);
    my $orig_dir = acl::Common::get_original_dir();
    chdir $orig_dir or acl::Common::mydie("Cannot change back into directory $orig_dir: $!");
  }
  # TODO: else Future support to be able to build performance accurate memory model during compile time
}

# Create a simulation system at compile time, copy over the top level testbench
sub _opencl_sim_generate_system($$$$$) {
  my ($devicefamily, $acl_board_hw_path, $use_snoop, $bcxml_file, $fulllog) = @_;
  my $verbose = acl::Common::get_verbose();
  my $quiet_mode = acl::Common::get_quiet_mode();
  my $sopc_builder_cmd = "qsys-script";
  my $ip_gen_cmd = 'qsys-generate';

  # Create the complete simulation system for less accurate memory model or not previous created folder
  print "Creating simulation system...\n" if $verbose && !$quiet_mode;
  my $qsys_quartus_project = "--quartus-project=none";  # only supports >=18.0 pro version
  # Copy over all ipx and iipx files from share/lib folder so Qsys can find the aoc cosim IP's.
  my @ipx_filelist = ("iface.ipx", "hw_iface.iipx", "sw_iface.iipx");
  foreach my $ipx_file (@ipx_filelist) {
    acl::File::copy(acl::Env::sdk_root()."/share/lib/opencl_sim/".$ipx_file, $ipx_file);
  }
  if ($board_qsys) {
    acl::Env::create_opencl_ipx(".");
    # Less accurate memory model and -skip-qsys flow uses to stitch together the whole system
    # TODO: case:576491 Use System Integrator to generate empty_kernel_hw.tcl
    #       temporary workaround parse .bc.xml and copy over example kernel system hw tcl
    _create_empty_kernel_system();
  }
  # TODO: cache some information about boardspec.xml to the folder so the simulation framework matches later
  my $generate_system_script = 'aoc_create_msim_system.tcl';
  _generate_msim_system_wrapper_tcl($devicefamily, $use_snoop, $bcxml_file, $generate_system_script);
  my $return_status = acl::Common::mysystem_full( 
    {'time' => 1, 'time-label' => 'qsys-script-simulation, ', 'stdout' => 'qsys-script.tmp', 'stderr' => '&STDOUT'},
    "$sopc_builder_cmd --script=$generate_system_script $qsys_quartus_project");
  acl::Common::move_to_log("!========== create-simulation ==========","qsys-script.tmp",$fulllog);
  $return_status == 0 or acl::Common::mydie("Simulation system creation FAILED.\nRefer to $fulllog for details.\n");
  
  # If ipx files are not present, generate them 
  if (! -e "iface.ipx") {
      print "Generating ipx...\n" if $verbose && !$quiet_mode;
  $return_status = acl::Common::mysystem_full( 
    {'time' => 1, 'time-label' => 'qsys-generate-ipx, ', 'stdout' => 'ipxgen.tmp', 'stderr' => '&STDOUT'},
    "ip-make-ipx --source-directory=\"".acl::Env::sdk_root()."/ip/board\" --output=iface.ipx  --relative-vars=INTELFPGAOCLSDKROOT");  
  }
  
  # Generate the simulatable HDL  
  print "Generating simulation system...\n" if $verbose && !$quiet_mode;
  $return_status = acl::Common::mysystem_full( 
    {'time' => 1, 'time-label' => 'qsys-generate-simulation, ', 'stdout' => 'ipgen.tmp', 'stderr' => '&STDOUT'},
    "$ip_gen_cmd --family=\"$devicefamily\" ${sim_qsys_name}.qsys --simulation $qsys_quartus_project --jvm-max-heap-size=3G --clear-output-directory");
  acl::Common::move_to_log("!========== generate-simulation ==========","ipgen.tmp",$fulllog);
  $return_status == 0 or acl::Common::mydie("Simulation system generation FAILED.\nRefer to $fulllog for details.\n");
  # Write the emif access script to determine how EMIF write and read from host
  _generate_memory_copy_function($sim_script_dir);
}

sub _create_empty_kernel_system() {
  # TODO: call system integrator to generate the empty_kernel_system_hw.tcl file
  my $empty_ks_script = acl::Env::sdk_root()."/share/lib/opencl_sim/empty_kernel_system_hw.tcl";
  my $kernel_system_rtl = acl::Env::sdk_root()."/share/lib/opencl_sim/kernel_system.v";
  acl::File::copy($empty_ks_script, "empty_kernel_system_hw.tcl");
  acl::File::copy($kernel_system_rtl, "kernel_system.v") if (! (-e "kernel_system.v"));  # don't over existing one
}

sub _generate_msim_system_wrapper_tcl($$$$) {
  my ($devicefamily, $use_snoop, $bcxml_file, $outfile) = @_;
  my $qsys_generate_system_script = acl::Env::sdk_root()."/share/lib/tcl/aoc_sim_generate_qsys.tcl";
  # TODO: case:520397 Enable Interleave slave bfm memory
  #       open board spec and get memory size, interleaving, and interleaving size if applicable
  #       set the variables then source the script
  my $host_to_dev_width = 0;
  my $dev_to_host_width = 0;
  open(BCXML_FH, $bcxml_file) or acl::Common::mydie("Couldn't open ${bcxml_file} for write! : $!\n");
  while (<BCXML_FH>) {
    my $line = $_;
    if ($line =~ /<INTERFACE port.*chan_id=\S+host/) {
      if ($line =~ /width="(\d+)".*optype="read"/) {
        $host_to_dev_width = $1;
      }
      elsif ($line =~ /width="(\d+)".*optype="write"/) {
        $dev_to_host_width = $1;
      }
      # else error out!
    }
  }
  close BCXML_FH;
  open(TCL, ">$outfile") or acl::Common::mydie("Couldn't open ${outfile} for write! : $!\n");
  print TCL "set INCL_KERNEL_SYSTEM 1\n" if (! $board_qsys);
  print TCL "set USE_SNOOP 1\n" if ($use_snoop);
  print TCL "set HOST_TO_DEV_READ_WIDTH ${host_to_dev_width}\n";
  print TCL "set DEV_TO_HOST_WRITE_WIDTH ${dev_to_host_width}\n";
  print TCL "set GLB_MEM_AV_WAITREQUEST_ALLOWANCE 6\n" if ($devicefamily =~ /Stratix 10/);
  print TCL "source \"$qsys_generate_system_script\"\n";
  close(TCL);
}

=head2 write_sim_repackage_script($work_dir)

Write out a repackage script for user to simply modify tb or run script without invoking compliation

=cut

sub write_sim_repackage_script($) {
  my $pkg_filepath = shift;
  my $sim_repkg_filename = (acl::Env::is_windows()) ? "sim_repackage.cmd" : "sim_repackage.sh";
  open SIM_REPKG_FH, ">$sim_repkg_filename" or acl::Common::mydie("Couldn't open $sim_repkg_filename for write.\n");
  print SIM_REPKG_FH get_sim_compile_exe() . " > recompile.log\n";
  my $pkg_string = join(" ", get_sim_package())." ".get_sim_options();
  print SIM_REPKG_FH "aocl binedit fpga-sim.bin package sys_description.hex $pkg_string\n";
  print SIM_REPKG_FH "aocl binedit $pkg_filepath set .acl.fpga.bin fpga-sim.bin\n";
  if (acl::Env::is_windows()) {
    print SIM_REPKG_FH "del fpga-sim.bin";
  }
  else {
    print SIM_REPKG_FH "rm -f fpga-sim.bin";
  }
  close SIM_REPKG_FH;
}

1;
